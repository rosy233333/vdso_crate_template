# vdso模板重构-debug笔记

## 链接与重定位相关bug

### 编译时链接bug

在将声明和使用共享数据的功能分离到`vdso_helper`库后，在编译时出现了链接器错误：

```
section .rela.dyn LMA overlaps section .data LMA
```

查询得知，LMA指加载地址，该错误表明两个段的加载地址发生了重叠。这是由`vdso`模块中的自定义链接脚本导致的问题，因为如果不使用自定义链接脚本，则不会产生该问题。然而，为了保证`get_code_base`函数（原先的`get_data_base`函数）获取到正确的地址，需要使用自定义的链接脚本。

询问deepseek有关overlap问题的几种解决方案后，发现其中一种方式是在链接脚本中显式声明某些段。因为链接脚本中未声明的段会自动分配空间，而这部分空间可能与显式声明的段的空间重叠。（实际上，在上文的报错中，的确是`.rela.dyn`未声明、`.data`有声明）。

根据以上思路，将出现错误的段显式声明出来，解决了该问题。

### 运行时重定位bug

解决了如上问题后，在运行时又出现了错误。在用户态测试中，直接报段错误，没有其它提示。在AsyncOS的内核态测试中，得知了出现`CodePageFault`，以及出错的`pc`。

出错的`pc`的值落在了正常的代码范围之外，且高位全部为0，可以得知原因是某个函数没有重定位，调用该函数时跳转到了其以0x0为基址的加载地址，而非实际的加载地址导致的。

通过`riscv64-unknown-elf-objdump -s -d libvdsoexample.so > disasm.s`反编译so文件，并与用户态测试中的CPU log`qemu.log`、内核态测试中Trapframe中的`ra`比较，得知了出错代码附近的指令执行流程：

代码首先想调用`get_code_base`函数，其先查询`.got.plt`表，再调用动态链接器重定位`get_code_base`，最后跳转到GOT表（在我们的链接脚本中，放在了`.data`段中），获得`get_code_base`的实际地址。然而，由于我们的加载流程中，只在加载时进行了重定位，而没有提供运行时重定位的支持，因此其获得的`get_code_base`的地址仍是定位前的地址，导致了错误。（这一段流程可见[链接、装载与库/动态链接/延迟绑定](https://github.com/rosy233333/weekly-progress/blob/master/25.3.13~25.3.19/%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB--%E9%93%BE%E6%8E%A5%E3%80%81%E8%A3%85%E8%BD%BD%E4%B8%8E%E5%BA%93%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.md#%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9Aplt)）

进一步发现，导致了该错误的`get_code_base`的重定位项，类型为`R_RISCV_JUMP_SLOT`。在RISC-V文档和`elf-parser`的实现中，对该重定位项的处理都是保持不动，等到运行时再调用动态链接器进行重定位。因为我们没有运行时重定位的支持，因此我将`elf-parser`对该类重定位项的处理改为了在加载时重定位（也就是，加上了加载基址）。经过这样的处理后，就可以正常运行了。